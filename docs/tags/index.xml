<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tags on Don&#39;t Panic</title>
    <link>https://commaok.xyz/tags/</link>
    <description>Recent content in Tags on Don&#39;t Panic</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
        <atom:link href="https://commaok.xyz/tags/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>git rebase --fork-point considered harmful (by me)</title>
      <link>https://commaok.xyz/post/fork-point/</link>
      <pubDate>Mon, 02 Nov 2020 09:12:48 -0700</pubDate>
      
      <guid>https://commaok.xyz/post/fork-point/</guid>
      <description>&lt;p&gt;This is the first blog post I&#39;ve written that isn&#39;t about Go, and it&#39;s pretty weedy. Feel free to stop reading now.&lt;/p&gt;
&lt;p&gt;This is a git &lt;a href=&#34;https://github.com/golang/go/wiki/ExperienceReports&#34;&gt;experience report&lt;/a&gt; based on something that bit me hard today, despite being quite experienced with git. Play along!&lt;/p&gt;
&lt;h1 id=&#34;prologue&#34;&gt;Prologue&lt;/h1&gt;
&lt;p&gt;Initialize a repo. Create two commits.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git init .
Initialized empty Git repository in &amp;lt;redacted&amp;gt;

$ touch readme
$ git add readme
$ git commit -a -m &amp;quot;initial commit&amp;quot;
[main (root-commit) ac2d8e7] initial commit
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 readme

$ touch readme.2
$ git add readme.2
$ git commit -a -m &amp;quot;another commit&amp;quot;
[main fb0f7fe] another commit
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 readme.2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So far, pretty mundane. Here&#39;s what the repo looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --all --decorate --oneline --graph
* fb0f7fe (HEAD -&amp;gt; main) another commit
* ac2d8e7 initial commit
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;oops&#34;&gt;Oops&lt;/h1&gt;
&lt;p&gt;I meant to create &lt;code&gt;readme.2&lt;/code&gt; on a branch. No problem. Let&#39;s create that branch now.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout -b branch
Branch &#39;branch&#39; set up to track local branch &#39;main&#39; by rebasing.
Switched to a new branch &#39;branch&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Oh, and better put &lt;code&gt;main&lt;/code&gt; back where it belongs.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout main
Switched to branch &#39;main&#39;
$ git reset --hard head~1
HEAD is now at ac2d8e7 initial commit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now the repo looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --all --decorate --oneline --graph
* 95cc2c0 (branch) another commit
* 20a231b (HEAD -&amp;gt; main) initial commit
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;bug-fix&#34;&gt;Bug fix&lt;/h1&gt;
&lt;p&gt;Let&#39;s fix a bug on main.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ echo &amp;quot;nothing to see here&amp;quot; &amp;gt; readme
$ git commit -a -m &amp;quot;fill out the readme&amp;quot;
[main eebece5] fill out the readme
 1 file changed, 1 insertion(+)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now &lt;code&gt;main&lt;/code&gt; and &lt;code&gt;branch&lt;/code&gt; have diverged a bit.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --all --decorate --oneline --graph
* eebece5 (HEAD -&amp;gt; main) fill out the readme
| * fb0f7fe (branch) another commit
|/  
* ac2d8e7 initial commit
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;time-to-rebase&#34;&gt;Time to rebase&lt;/h1&gt;
&lt;p&gt;Let&#39;s get &lt;code&gt;branch&lt;/code&gt; rebased onto &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout branch
Switched to branch &#39;branch&#39;
Your branch and &#39;main&#39; have diverged,
and have 1 and 1 different commits each, respectively.
  (use &amp;quot;git pull&amp;quot; to merge the remote branch into yours)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Before reading any further, stop. Summon your git fu. What will happen when we run &lt;code&gt;git rebase&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;If you&#39;re like me, you expect something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 7a8805e (HEAD -&amp;gt; branch) another commit
* eebece5 (main) fill out the readme
* ac2d8e7 initial commit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Three commits. &lt;code&gt;branch&lt;/code&gt; has been rebased on top of &lt;code&gt;main&lt;/code&gt;, so it is one commit ahead of it.&lt;/p&gt;
&lt;p&gt;OK, let&#39;s find out what really happens.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git rebase
Successfully rebased and updated refs/heads/branch.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Moment of truth.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --all --decorate --oneline --graph
* eebece5 (HEAD -&amp;gt; branch, main) fill out the readme
* ac2d8e7 initial commit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are only two commits. &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;main&lt;/code&gt; are on the same commit.&lt;/p&gt;
&lt;p&gt;What happened to the third commit? It&#39;s gone.&lt;/p&gt;
&lt;h1 id=&#34;denouement&#34;&gt;Denouement&lt;/h1&gt;
&lt;p&gt;What happened was &lt;code&gt;--fork-point&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The first step to a rebase (and many other operations) is to find a &lt;a href=&#34;https://git-scm.com/docs/git-merge-base&#34;&gt;merge base&lt;/a&gt;. This is some shared commit in history, common ground from which to trace divergent paths.&lt;/p&gt;
&lt;p&gt;The most obvious way to find a merge base is by looking at the graph for the most recent commit reachable by everyone.&lt;/p&gt;
&lt;p&gt;But inspecting the graph doesn&#39;t always get you the ideal result. What if you intentionally abandoned some commits on &lt;code&gt;main&lt;/code&gt;? Looking just at the graph to find the merge base might accidentally resuscitate them. There&#39;s a &lt;a href=&#34;https://git-scm.com/docs/git-merge-base#_discussion_on_fork_point_mode&#34;&gt;fully worked example&lt;/a&gt; in the git docs.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;--fork-point&lt;/code&gt; flag is a clever attempt to work around this. &lt;code&gt;git rebase&lt;/code&gt; describes it thus:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Use reflog to find a better common ancestor between &lt;code&gt;upstream&lt;/code&gt; and &lt;code&gt;branch&lt;/code&gt; when calculating which commits have been introduced by &lt;code&gt;branch&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;a href=&#34;https://git-scm.com/docs/git-reflog&#34;&gt;git reflog&lt;/a&gt; is a log of changes made to git refs. (If you don&#39;t know what a &amp;ldquo;ref&amp;rdquo; is, substitute the word &amp;ldquo;branch&amp;rdquo;.) It&#39;s meta version control. It tracks what you did with your version control over time.&lt;/p&gt;
&lt;p&gt;The reflog is quite useful if you make a horrible mistake. You can poke through the reflog to find a lost commit.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--fork-point&lt;/code&gt; looks through the &lt;em&gt;temporal history of your git repo&lt;/em&gt; to pick a merge base, &amp;ldquo;allowing you to replay only the commits on your topic, excluding the commits the other side later discarded.&amp;rdquo; In this context, &amp;ldquo;later&amp;rdquo; really means later in time, not &amp;ldquo;descendent of&amp;rdquo; in abstract git graph world.&lt;/p&gt;
&lt;p&gt;And here we have the explanation for what happened. I discovered I had committed on &lt;code&gt;main&lt;/code&gt; by accident, and &lt;em&gt;reset &lt;code&gt;main&lt;/code&gt; to the previous commit&lt;/em&gt;. From &lt;code&gt;--fork-point&lt;/code&gt;&#39;s perspective, the &lt;code&gt;main&lt;/code&gt; branch had &lt;em&gt;discarded&lt;/em&gt; the commit on &lt;code&gt;branch&lt;/code&gt;. Therefore it was not included when we selected a merge base to rebase &lt;code&gt;branch&lt;/code&gt; onto &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;whats-wrong-here&#34;&gt;What&#39;s wrong here?&lt;/h1&gt;
&lt;p&gt;To my mind, two things went wrong here.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--fork-point&lt;/code&gt; assumes that discarded commits were discarded &lt;em&gt;because they were unwanted&lt;/em&gt;. But that is not always true. In my case, they were discarded because they were unwanted &lt;em&gt;at that moment&lt;/em&gt;. Adding more clever heuristics might help some here, but I suspect it&#39;s impossible to infer intent, which is what is required.&lt;/p&gt;
&lt;p&gt;The bigger issue is that the behavior of &lt;code&gt;git rebase&lt;/code&gt; now depends on (almost) invisible, inscrutable state. The ability to mentally model what a command will do is critical to being able to use any tool. It&#39;s pretty easy to view a git graph; it is the default view for most git UIs. And it&#39;s not too hard as a human to pick out the topological merge base from there. The reflog is all but invisible. And it is definitely not easy for a human to process.&lt;/p&gt;
&lt;h1 id=&#34;the-fix&#34;&gt;The fix&lt;/h1&gt;
&lt;p&gt;The solution is obviously more flags. My git config&#39;s &lt;code&gt;[alias]&lt;/code&gt; section now includes &lt;code&gt;r = rebase --no-fork-point&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generating safer Go code</title>
      <link>https://commaok.xyz/post/safer-generated-code/</link>
      <pubDate>Wed, 28 Oct 2020 09:12:48 -0700</pubDate>
      
      <guid>https://commaok.xyz/post/safer-generated-code/</guid>
      <description>&lt;p&gt;It&#39;s easy to forget to call &lt;code&gt;go generate&lt;/code&gt; when you need to. Failure to regenerate can mean nasty bugs.&lt;/p&gt;
&lt;p&gt;Venerable gopher &lt;a href=&#34;https://github.com/rogpeppe/&#34;&gt;Rog Peppe&lt;/a&gt; found an excellent technique for guarding against this class of bugs. Like many good ideas, it is obvious in retrospect.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Generate code that will not compile if needs to be regenerated.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I&#39;ll illustrate this with two examples.&lt;/p&gt;
&lt;h3 id=&#34;stringer&#34;&gt;stringer&lt;/h3&gt;
&lt;p&gt;The first example comes directly from Rog, in the &lt;a href=&#34;https://pkg.go.dev/golang.org/x/tools/cmd/stringer&#34;&gt;&lt;code&gt;stringer&lt;/code&gt;&lt;/a&gt; command. &lt;code&gt;stringer&lt;/code&gt; generates a &lt;code&gt;String() string&lt;/code&gt; method for integer types that have defined constants.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; (
    &lt;span style=&#34;color:#a6e22e&#34;&gt;One&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;Two&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;stringer&lt;/code&gt; will generate a method that returns &lt;code&gt;&amp;quot;One&amp;quot;&lt;/code&gt; for &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;&amp;quot;Two&amp;quot;&lt;/code&gt; for &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;&amp;quot;T(3)&amp;quot;&lt;/code&gt; for &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What if you now change the value of &lt;code&gt;One&lt;/code&gt; to be &lt;code&gt;3&lt;/code&gt; and forget to re-generate?&lt;/p&gt;
&lt;p&gt;Well, &lt;code&gt;stringer&lt;/code&gt; also generated this function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;() {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt;{}
	&lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;One&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
	&lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;Two&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The function is named &lt;code&gt;_&lt;/code&gt;, which means it is impossible to call it. The compiler won&#39;t even bother generating code for it. It will, however, typecheck it. And typechecking is where the magic happens.&lt;/p&gt;
&lt;p&gt;When the value of &lt;code&gt;One&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;x[One-1]&lt;/code&gt; evaluates to &lt;code&gt;x[0]&lt;/code&gt;. Since &lt;code&gt;x&lt;/code&gt; has length &lt;code&gt;1&lt;/code&gt;, that&#39;s OK.&lt;/p&gt;
&lt;p&gt;When the value of &lt;code&gt;One&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;x[One-1]&lt;/code&gt; evaluates to &lt;code&gt;x[2]&lt;/code&gt;. But &lt;code&gt;x&lt;/code&gt; only has length &lt;code&gt;1&lt;/code&gt;! Attempts to compile this generate a compiler error: &lt;code&gt;invalid array index One - 1 (out of bounds for 1-element array)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The function &lt;em&gt;recorded the values of the constants when stringer was run&lt;/em&gt; and &lt;em&gt;fails to compile if those values change&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&#34;cloner&#34;&gt;cloner&lt;/h3&gt;
&lt;p&gt;Now that we know the trick, we can apply it elsewhere.&lt;/p&gt;
&lt;p&gt;Tailscale has a little bespoke &lt;a href=&#34;https://github.com/tailscale/tailscale/blob/main/cmd/cloner/cloner.go&#34;&gt;tool to generate Clone methods for structs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The output of &lt;code&gt;cloner&lt;/code&gt; depends on the input struct fields. How can we trigger a compilation failure if we forget to re-run the tool after changing an input struct?&lt;/p&gt;
&lt;p&gt;The trick is to duplicate the original struct in the generated code and then attempt to convert from the original struct to the current struct.&lt;/p&gt;
&lt;p&gt;We start with this input code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
	&lt;span style=&#34;color:#a6e22e&#34;&gt;X&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;After generating a &lt;code&gt;Clone&lt;/code&gt; method for &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;cloner&lt;/code&gt; also generates:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
	&lt;span style=&#34;color:#a6e22e&#34;&gt;X&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
}{})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here we&#39;ve written out the exact form of &lt;code&gt;T&lt;/code&gt; when we generated the code, and assigned it to &lt;code&gt;_&lt;/code&gt;, which the compiler can discard. However, it still must be typechecked.&lt;/p&gt;
&lt;p&gt;Suppose we now change the type &lt;code&gt;T&lt;/code&gt;. Let&#39;s add a new field.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
	&lt;span style=&#34;color:#a6e22e&#34;&gt;X&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;Y&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The conversion now fails: It&#39;s not possible to convert a &lt;code&gt;struct { X int }&lt;/code&gt; to a &lt;code&gt;struct { X int; Y string }&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Similar to stringer, cloner &lt;em&gt;recorded the types when cloner was run&lt;/em&gt; and now &lt;em&gt;fails to compile if those types change&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&#34;compile-time-assertion-taxonomy&#34;&gt;Compile-time assertion taxonomy&lt;/h3&gt;
&lt;p&gt;We&#39;ve seen two forms of assertions that can trigger during typechecking: x == y and a struct&#39;s fields are unchanged.&lt;/p&gt;
&lt;p&gt;There are others. For example, you can use conversions to assert that a type implements an interface. You can use conversion to uint to assert that one untyped constant is greater than or equal to than another. (You can&#39;t convert a negative constant to uint.)&lt;/p&gt;
&lt;p&gt;There are some obscure ones, of questionable utility. For example, you could assert that two concrete types are distinct by putting them both as cases in a type switch, which disallows duplicate types.&lt;/p&gt;
&lt;p&gt;I don&#39;t know of any attempt to exhaustively list compile-time assertions (aside from the spec) and how they can be used, with examples. Someone please make one!&lt;/p&gt;
&lt;p&gt;Matthew Dempsky has &lt;a href=&#34;https://github.com/golang/go/issues/34868&#34;&gt;proposed that Go add explicit compile time assertions&lt;/a&gt; for boolean expressions. (That doesn&#39;t cover relationships between types, although maybe generics would break some new ground here.) And I&#39;ve written about a quirky way that you can write &lt;a href=&#34;https://commaok.xyz/post/compile-time-assertions/&#34;&gt;link-time assertions&lt;/a&gt; in Go.&lt;/p&gt;
&lt;h3 id=&#34;call-to-action&#34;&gt;Call to action&lt;/h3&gt;
&lt;p&gt;If you maintain a code generator, please check whether you can use this technique to protect your users from bugs. One obvious category is generated serialization/deserialization routines. There are almost certainly others.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Discovering alloc size classes in Go</title>
      <link>https://commaok.xyz/post/discovering-size-classes/</link>
      <pubDate>Tue, 01 Sep 2020 09:12:48 -0700</pubDate>
      
      <guid>https://commaok.xyz/post/discovering-size-classes/</guid>
      <description>&lt;p&gt;As of Go 1.15, the Go runtime&#39;s &lt;a href=&#34;https://github.com/golang/go/blob/12c01f7/src/runtime/malloc.go&#34;&gt;memory allocator&lt;/a&gt; doesn&#39;t always allocate exactly the number of bytes required for an object. Instead, it rounds up to the nearest &lt;em&gt;size class&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int64&lt;/span&gt;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Type &lt;code&gt;T&lt;/code&gt; has a size of 9 bytes, but allocating a &lt;code&gt;T&lt;/code&gt; will use 16 bytes.&lt;/p&gt;
&lt;p&gt;If you&#39;re trying to &lt;a href=&#34;https://go-review.googlesource.com/c/go/+/41797/&#34;&gt;reduce the memory usage of a program that allocates a lot of one particular type of object&lt;/a&gt;, it&#39;s good to be aware of the size classes, as the impact of shrinking the object will be a step function.&lt;/p&gt;
&lt;h1 id=&#34;what-are-the-size-classes&#34;&gt;What are the size classes?&lt;/h1&gt;
&lt;p&gt;The easiest way to find out the size classes is to &lt;a href=&#34;https://github.com/golang/go/blob/12c01f7698cd257b7d2e4795b0f8a971ec8533b6/src/runtime/sizeclasses.go&#34;&gt;read the source&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It&#39;s also possible to discover them at run time!&lt;/p&gt;
&lt;p&gt;The trick is to use &lt;code&gt;append&lt;/code&gt;. &lt;code&gt;append&lt;/code&gt; gets to choose the capacity of the returned slice. And, as you would hope, &lt;code&gt;append&lt;/code&gt; is &lt;a href=&#34;https://github.com/golang/go/blob/12c01f7698cd257b7d2e4795b0f8a971ec8533b6/src/runtime/slice.go#L201&#34;&gt;aware of the allocator&lt;/a&gt;; it picks a cap that fills as much as possible of the size class it selected.&lt;/p&gt;
&lt;p&gt;We are going to start with a nil slice, cap 0. We will then append &lt;code&gt;n&lt;/code&gt; bytes to it. &lt;code&gt;append&lt;/code&gt; will helpfully round &lt;code&gt;n&lt;/code&gt; up to the nearest size class as the new cap.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sizeup&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
	&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; append([]byte(&lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;), make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;)
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; cap(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you &lt;a href=&#34;https://play.golang.org/p/hAfgbpwa45t&#34;&gt;run this in a loop&lt;/a&gt;, you get a nice size class list. In the unlikely event that you were going to do this in a real program, you&#39;d probably calculate the size classes at startup and cache them.&lt;/p&gt;
&lt;p&gt;This technique relies on an implementation detail, but hey, the mere existence of size classes is also an implementation detail.&lt;/p&gt;
&lt;h1 id=&#34;who-cares&#34;&gt;Who cares?&lt;/h1&gt;
&lt;p&gt;In particularly performance sensitive code, it sometimes makes sense to overallocate a slice, to avoid allocation in subsequent appends, such as in &lt;a href=&#34;https://github.com/golang/go/blob/master/src/math/big/nat.go#L68&#34;&gt;math/big&lt;/a&gt;. When deciding how much to overallocate, you might want to be size-class aware, so as not to waste capacity that is effectively free. See &lt;a href=&#34;https://github.com/golang/go/issues/24204&#34;&gt;#24204&lt;/a&gt; for interesting related discussion.&lt;/p&gt;
&lt;p&gt;And there&#39;s an interesting generics connection. People are fond of pointing out that generics would obviate the need for &lt;code&gt;append&lt;/code&gt;. You could implement it yourself. But if you want your custom &lt;code&gt;append&lt;/code&gt; to be as optimized as the runtime&#39;s, you need to be aware of the size classes.&lt;/p&gt;
&lt;h1 id=&#34;why-not-hard-code-the-size-classes&#34;&gt;Why not hard-code the size classes?&lt;/h1&gt;
&lt;p&gt;They change.&lt;/p&gt;
&lt;p&gt;Hard-coding the size classes, per-release, behind build tags, is a fine idea. But they&#39;re also pretty easy to calculate.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Life without line numbers</title>
      <link>https://commaok.xyz/post/no-line-numbers/</link>
      <pubDate>Thu, 30 Apr 2020 08:12:48 -0700</pubDate>
      
      <guid>https://commaok.xyz/post/no-line-numbers/</guid>
      <description>&lt;p&gt;If you are desperate for 6% smaller Go binaries, this blog post is for you. (I did this experiment to help out &lt;a href=&#34;https://www.tailscale.com/&#34;&gt;Tailscale&lt;/a&gt;. Disclosure: I&#39;m an investor.) If binary size doesn&#39;t worry you, well, maybe you&#39;ll find it entertaining.&lt;/p&gt;
&lt;p&gt;In order to get example numbers for this post, I grabbed a random item from my GOPATH. All the hard numbers in this blog post are for &lt;code&gt;github.com/mvdan/sh/cmd/shfmt&lt;/code&gt;. From a bit of experimenting, they seem fairly representative.&lt;/p&gt;
&lt;p&gt;I am using &lt;a href=&#34;https://github.com/golang/go/commit/9d812cfa5c&#34;&gt;commit 9d812cfa5c&lt;/a&gt; of the Go toolchain as my base commit. This is the &lt;code&gt;master&lt;/code&gt; branch as of April 29, 2020; it will probably be similar to the Go 1.15beta1 release. I&#39;m using it rather than Go 1.14 because it contains several binary size reductions, including &lt;a href=&#34;https://go-review.googlesource.com/c/go/+/230544&#34;&gt;one in particular&lt;/a&gt; that you&#39;ll definitely want if you&#39;re concerned about binary sizes.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;There are lots of ways to shrink a binary. Removing extraneous dependencies is probably the best way. &lt;a href=&#34;https://go-review.googlesource.com/c/go/+/210284&#34;&gt;Avoiding global maps through judicious use of sync.Once&lt;/a&gt; can help. &lt;a href=&#34;https://go-review.googlesource.com/c/go/+/228111&#34;&gt;Keeping separable code separate by indirection&lt;/a&gt; can help. You can &lt;a href=&#34;https://twitter.com/bradfitz/status/1255704982893912064&#34;&gt;suppress equality algorithm generation&lt;/a&gt; (ick&amp;hellip;until you really need it). You can usually save double-digit percentages by stripping debugging information: pass &lt;a href=&#34;https://github.com/golang/go/issues/38777&#34;&gt;&lt;code&gt;-ldflags=-w&lt;/code&gt; to &lt;code&gt;go build&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let&#39;s assume you&#39;ve done all that. And you still need to shrink more. And that need is so pressing you&#39;re willing to make some sacrifices for it.&lt;/p&gt;
&lt;p&gt;Go binaries contain a lot more than just executable code. There are type descriptors that describe the types in a Go program. There are garbage collection data structures. There&#39;s debugger information. And there are mappings from PCs to position information. (And there&#39;s lots more, too.)&lt;/p&gt;
&lt;p&gt;We&#39;re going to get rid of the position information.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;We can&#39;t just strip out the position information entirely from the binary. That would break lots of stuff.&lt;/p&gt;
&lt;p&gt;But we can make all the line numbers the same. That shouldn&#39;t break anything. After all, no one (except gofmt) said we had to put our code on multiple lines.&lt;/p&gt;
&lt;p&gt;For example, instead of &lt;a href=&#34;https://play.golang.org/&#34;&gt;this&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
)

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
	&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, playground&amp;#34;&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We could write &lt;a href=&#34;https://play.golang.org/p/skI5nMleZgt&#34;&gt;this&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; ( &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt; ); &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() { &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, playground&amp;#34;&lt;/span&gt;) }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The Go compiler and runtime has to be prepared for lots of stuff to be on one line.&lt;/p&gt;
&lt;p&gt;We could write a preprocessor, maybe using &lt;a href=&#34;https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies&#34;&gt;&lt;code&gt;-toolexec&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;https://golang.org/cmd/compile/#hdr-Compiler_Directives&#34;&gt;&lt;code&gt;//line&lt;/code&gt; directives&lt;/a&gt;, but it&#39;s easier to just hack the compiler. Fortunately, this is well-factored code, so we only need to touch two little spots.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-diff&#34; data-lang=&#34;diff&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;--- a/src/cmd/compile/internal/syntax/pos.go
&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;+++ b/src/cmd/compile/internal/syntax/pos.go
&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;@@ -23,3 +23,3 @@ type Pos struct {
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; // MakePos returns a new Pos for the given PosBase, line and column.
&lt;span style=&#34;color:#f92672&#34;&gt;-func MakePos(base *PosBase, line, col uint) Pos { return Pos{base, sat32(line), sat32(col)} }
&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;+func MakePos(base *PosBase, line, col uint) Pos { return Pos{base, 1, 1} }
&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&lt;/span&gt; 
&lt;span style=&#34;color:#75715e&#34;&gt;@@ -101,2 +101,3 @@ type PosBase struct {
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; func NewFileBase(filename string) *PosBase {
&lt;span style=&#34;color:#a6e22e&#34;&gt;+       filename = &amp;#34;x.go&amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&lt;/span&gt;        base := &amp;amp;PosBase{MakePos(nil, linebase, colbase), filename, linebase, colbase}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Every file is now named &lt;code&gt;x.go&lt;/code&gt;, and every source position has line 1 and column 1. (Columns don&#39;t actually matter for binary size, once you&#39;ve stripped DWARF.)&lt;/p&gt;
&lt;p&gt;This isn&#39;t quite enough. There are two other spots in the toolchain that get unhappy if all code lives at &lt;code&gt;x.go:1:1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The first is in &lt;a href=&#34;https://github.com/golang/go/issues/38698&#34;&gt;constructing DWARF&lt;/a&gt;, for debuggers. We can just remove that check: We are already stripping DWARF, so generating invalid DWARF doesn&#39;t matter.&lt;/p&gt;
&lt;p&gt;The second is in cgo. There are some security checks about where certain cgo pragma can be located. We&#39;re going to trust ourselves not to violate them (by ensuring all code keeps building with an unaltered toolchain), and remove that security check.&lt;/p&gt;
&lt;p&gt;The full diff is at &lt;a href=&#34;https://github.com/josharian/go/commit/1a3e66ceed&#34;&gt;https://github.com/josharian/go/commit/1a3e66ceed&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Now all code we compile has &lt;code&gt;x.go:1:1&lt;/code&gt; as its position.&lt;/p&gt;
&lt;p&gt;Our program, compiled with &lt;code&gt;-ldflags=-w&lt;/code&gt;, shrinks from 3,126,800 bytes to 2,938,384 bytes, or about 6%.&lt;/p&gt;
&lt;p&gt;Most of this is from shrinking the encoding of position information. A little bit of it comes from a compiler optimization.&lt;/p&gt;
&lt;p&gt;These two programs compile slightly differently:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
    &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you run &lt;code&gt;go tool compile -S x.go&lt;/code&gt; on each of these files, you&#39;ll see that &lt;a href=&#34;https://godbolt.org/z/UFf2JL&#34;&gt;the first program&lt;/a&gt; contains two separate calls to &lt;code&gt;runtime.panicIndex&lt;/code&gt;. &lt;a href=&#34;https://godbolt.org/z/26rRog&#34;&gt;The second program&lt;/a&gt; contains only one such call. The reason is that &lt;code&gt;runtime.panicIndex&lt;/code&gt; must display a backtrace containing the line number of the line that panicked. In the first program, we need two separate panics, one for each possible panicking line number. In the second program, we don&#39;t, so the compiler combines them.&lt;/p&gt;
&lt;p&gt;Since we are now putting all code on the same line, the compiler can combine more panics than before.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;What do we lose by doing this? Anything that needs accurate position information. Panic backtraces will still show you the PC, the function, the arguments, and so on. But all line numbers will be &lt;code&gt;x.go:1&lt;/code&gt;. With patience, you could still figure out the line number yourself based on the PC, but it&#39;d take some manual work. Pprof will still be able to analyze performance by function and by instruction, but it&#39;ll think everything happens on the same line, which will make analysis by line number useless.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Let&#39;s play around a bit. What if we ditch only filenames, and keep the true line numbers? It saves only 0.9%. And as you&#39;d then expect, keeping only accurate filenames and making all line number 1 saves 5.1%.&lt;/p&gt;
&lt;p&gt;So most of the savings are from the line numbers. What if we keep the original filenames, and truncate all line numbers to the nearest multiple of 16? That is, trim our diff down to:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-diff&#34; data-lang=&#34;diff&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;--- a/src/cmd/compile/internal/syntax/pos.go
&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;+++ b/src/cmd/compile/internal/syntax/pos.go
&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;@@ -23,3 +23,3 @@ type Pos struct {
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; // MakePos returns a new Pos for the given PosBase, line and column.
&lt;span style=&#34;color:#f92672&#34;&gt;-func MakePos(base *PosBase, line, col uint) Pos { return Pos{base, 1, 1} }
&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;+func MakePos(base *PosBase, line, col uint) Pos { return Pos{base, sat32(line/16*16 + 1), 1} }
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This cuts our binaries by 2.2%. Not bad. What if we divide all line numbers by 16 instead? That preserves exactly the same information as truncating, but we have to multiply by hand to get the &amp;ldquo;nearby&amp;rdquo; line number.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-diff&#34; data-lang=&#34;diff&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;--- a/src/cmd/compile/internal/syntax/pos.go
&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;+++ b/src/cmd/compile/internal/syntax/pos.go
&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;@@ -23,3 +23,3 @@ type Pos struct {
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; // MakePos returns a new Pos for the given PosBase, line and column.
&lt;span style=&#34;color:#f92672&#34;&gt;-func MakePos(base *PosBase, line, col uint) Pos { return Pos{base, 1, 1} }
&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;+func MakePos(base *PosBase, line, col uint) Pos { return Pos{base, sat32(line/16 + 1), 1} }
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This cuts our binaries by 2.75%! Why does &lt;code&gt;/16&lt;/code&gt; save 0.5% more than &lt;code&gt;/16*16&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Line numbers are stored in the binary using a &lt;a href=&#34;https://golang.org/pkg/encoding/binary/#PutVarint&#34;&gt;varint encoding&lt;/a&gt; relative to the previous line number. Smaller numbers mean smaller deltas, and can thus be stored more efficiently.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Interning strings in Go</title>
      <link>https://commaok.xyz/post/intern-strings/</link>
      <pubDate>Tue, 17 Dec 2019 08:12:48 -0700</pubDate>
      
      <guid>https://commaok.xyz/post/intern-strings/</guid>
      <description>&lt;p&gt;This blog post covers string interning in Go.&lt;/p&gt;
&lt;h1 id=&#34;what-is-a-string&#34;&gt;What is a string?&lt;/h1&gt;
&lt;p&gt;In Go, a string is &lt;a href=&#34;https://golang.org/ref/spec#String_types&#34;&gt;a (possibly empty) immutable sequence of bytes&lt;/a&gt;. The critical word here for our purposes is &lt;em&gt;immutable&lt;/em&gt;. Because byte slices are mutable, converting between &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;[]byte&lt;/code&gt; generally requires an alloc and copy, which is expensive.&lt;/p&gt;
&lt;p&gt;Under the hood, strings in Go are (currently) represented &lt;a href=&#34;https://research.swtch.com/godata&#34;&gt;as a length and a pointer to the string data&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;what-is-string-interning&#34;&gt;What is string interning?&lt;/h1&gt;
&lt;p&gt;Consider this code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []byte(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; string(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; string(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; are strings, so they both have a length and a data pointer. Their lengths are obviously the same. What about their data pointers?&lt;/p&gt;
&lt;p&gt;The Go language doesn&#39;t provide us a direct way to find out. But we can sniff around with unsafe:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pointer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)
    &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;reflect&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StringHeader&lt;/span&gt;)(&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Data&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(This function ought to return an &lt;code&gt;unsafe.Pointer&lt;/code&gt;. See &lt;a href=&#34;https://golang.org/issue/19367&#34;&gt;Go issue 19367&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;If we &lt;code&gt;fmt.Println(pointer(s), pointer(t))&lt;/code&gt;, we get something like &lt;code&gt;4302664 4302632&lt;/code&gt;. The pointers are different; there are two separate copies of the data &lt;code&gt;hello&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;(Here&#39;s a &lt;a href=&#34;https://play.golang.org/p/oyq6Pz79EGa&#34;&gt;playground link&lt;/a&gt; if you want to experiment. What happens if you change &lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt; to just &lt;code&gt;&amp;quot;h&amp;quot;&lt;/code&gt;? &lt;a href=&#34;https://golang.org/cl/97717&#34;&gt;Explanation.&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Suppose you wanted instead to re-use a single copy of the data &lt;code&gt;hello&lt;/code&gt;? That&#39;s &lt;a href=&#34;https://en.wikipedia.org/wiki/String_interning&#34;&gt;string interning&lt;/a&gt;. There are two advantages to interned strings. The obvious one is that you don&#39;t need to allocate and copy the data. The other is that it speeds up string equality checks. If two strings have the same length and same data pointer, they are equal; there is no need to actually examine the bytes.&lt;/p&gt;
&lt;p&gt;As of Go 1.14, Go doesn&#39;t intern most strings. Interning, like any form of caching, also has costs: synchronization for concurrency safety, garbage collector complexity, and extra code to execute every time a string is created. And, like caching, there are cases in which it is harmful rather than helpful. If you were processing a list of dictionary words, no word would ever occur twice, so interning strings would be waste both time and memory.&lt;/p&gt;
&lt;h1 id=&#34;manual-string-interning&#34;&gt;Manual string interning&lt;/h1&gt;
&lt;p&gt;It is possible to manually intern strings in Go. What we need is a way to look for an existing string to re-use given a byte slice, perhaps using something like a &lt;code&gt;map[[]byte]string&lt;/code&gt;. If a lookup succeeds, we use the existing string; if it fails, we convert and then store that string for future use.&lt;/p&gt;
&lt;p&gt;There&#39;s only one problem: You can&#39;t use &lt;code&gt;[]byte&lt;/code&gt; as a map key.&lt;/p&gt;
&lt;p&gt;Thanks to a &lt;a href=&#34;https://golang.org/cl/83740044&#34;&gt;long-standing compiler optimization&lt;/a&gt;, we can use a &lt;code&gt;map[string]string&lt;/code&gt; instead. The optimization is that map operations whose key is a converted byte slice don&#39;t actually generate a new string  to use during the lookup.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make(&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; []byte(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; string(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// allocates
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;[string(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;)] &lt;span style=&#34;color:#75715e&#34;&gt;// doesn&amp;#39;t allocate!
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(A similar optimization applies in other scenarios in which the compiler can prove that a converted byte slice doesn&#39;t get modified during use, such as &lt;a href=&#34;https://github.com/golang/go/blob/056a3d1c6f6f92b095f88b01d004eb2656a688c5/src/cmd/compile/internal/gc/swt.go#L249&#34;&gt;&lt;code&gt;switch string(b)&lt;/code&gt; when all switch cases are free of side-effects&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;The entirety of the code required to intern strings is this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;intern&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt; {
    &lt;span style=&#34;color:#75715e&#34;&gt;// look for an existing string to re-use
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;[string(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;)]
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ok&lt;/span&gt; {
        &lt;span style=&#34;color:#75715e&#34;&gt;// found an existing string
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;
    }
    &lt;span style=&#34;color:#75715e&#34;&gt;// didn&amp;#39;t find one, so make one and store it
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; string(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;)
    &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;] = &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Pretty simple.&lt;/p&gt;
&lt;h1 id=&#34;complications&#34;&gt;Complications&lt;/h1&gt;
&lt;p&gt;Note that this manual interning routine pushes the problems with interning into the calling code. You need to manage concurrent access to the map; you need to decide the lifetime of the map (and thus everything in it); and you need to pay the extra cost of a map lookup every time you need a string.&lt;/p&gt;
&lt;p&gt;Pushing these decisions onto the calling code can yield better performance. For example, suppose you were &lt;a href=&#34;https://golang.org/issue/32779&#34;&gt;decoding json into a &lt;code&gt;map[string]interface{}&lt;/code&gt;&lt;/a&gt;. The json decoder is probably not concurrent. The lifetime of the map can be tied to the json decoder. And the keys of this map are likely to be repeated frequently, which is the best case scenario for string interning; it makes the extra cost of the map lookup worth it.&lt;/p&gt;
&lt;h1 id=&#34;a-helper-package&#34;&gt;A helper package&lt;/h1&gt;
&lt;p&gt;If you don&#39;t want to have to think about any of these complications, and are willing to accept the slight concomitant loss of performance, and have code in which string interning may help, there&#39;s a package for that: &lt;a href=&#34;https://github.com/josharian/intern&#34;&gt;github.com/josharian/intern&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It works by horribly abusing &lt;code&gt;sync.Pool&lt;/code&gt;. It stores interning maps in a &lt;code&gt;sync.Pool&lt;/code&gt;, retrieving them as needed. This neatly solves the concurrent access problem, because &lt;code&gt;sync.Pool&lt;/code&gt; access is concurrency-safe. It mostly solves the lifetime problem, because the contents in a &lt;code&gt;sync.Pool&lt;/code&gt; are usually &lt;a href=&#34;https://golang.org/issue/22950&#34;&gt;eventually&lt;/a&gt; garbaged collected. (For related reading about managing lifetimes, see &lt;a href=&#34;https://golang.org/issue/29696&#34;&gt;Go issue 29696&lt;/a&gt;.)&lt;/p&gt;
&lt;h1 id=&#34;more-reading&#34;&gt;More reading&lt;/h1&gt;
&lt;p&gt;There&#39;s lots more discussion and links about string interning in Go in &lt;a href=&#34;https://golang.org/issue/5160&#34;&gt;issue 5160&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>testing.B.ReportMetric</title>
      <link>https://commaok.xyz/post/report-metric/</link>
      <pubDate>Wed, 03 Jul 2019 18:07:05 -0800</pubDate>
      
      <guid>https://commaok.xyz/post/report-metric/</guid>
      <description>&lt;p&gt;My favorite new API in Go 1.13 is &lt;a href=&#34;https://tip.golang.org/pkg/testing/#B.ReportMetric&#34;&gt;&lt;code&gt;testing.B.ReportMetric&lt;/code&gt;&lt;/a&gt;. It allows you to report custom metrics from within your benchmarks.&lt;/p&gt;
&lt;p&gt;When the API was &lt;a href=&#34;https://github.com/golang/go/issues/26037&#34;&gt;proposed&lt;/a&gt;, the motivating example was &lt;code&gt;package sort&lt;/code&gt;. The &lt;code&gt;package sort&lt;/code&gt; benchmarks, like all benchmarks, measure elapsed wall time and (optionally) allocations. But wall time measurements can be noisy, and the sort routines don&#39;t allocate much. There is another really useful algorithm-level metric for a sorting routine: How many comparisons does it perform?&lt;/p&gt;
&lt;p&gt;Let&#39;s use our new to API find out. Here&#39;s a simple sort benchmark.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;demo&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sort&amp;#34;&lt;/span&gt;
	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;testing&amp;#34;&lt;/span&gt;
)

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkSort&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
	&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
	&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResetTimer&lt;/span&gt;() &lt;span style=&#34;color:#75715e&#34;&gt;// ignore big allocation
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; {
			&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] = &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; ^ &lt;span style=&#34;color:#ae81ff&#34;&gt;0x2cc&lt;/span&gt;
		}
		&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StartTimer&lt;/span&gt;()
		&lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Slice&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
			&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;]
		})
		&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StopTimer&lt;/span&gt;()
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(Aside: Some of the sort benchmarks in the standard library allocate inside the loop. Oops. Carefully fixing this might make a nice first contribution for someone wanting to try their hand at the Go standard library.)&lt;/p&gt;
&lt;p&gt;On my machine, executing this looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go test -bench=. -count=5
goos: darwin
goarch: amd64
pkg: github.com/commaok/blog/content/post
BenchmarkSort-8   	   19536	     60568 ns/op
BenchmarkSort-8   	   19666	     60592 ns/op
BenchmarkSort-8   	   19569	     60674 ns/op
BenchmarkSort-8   	   19724	     61363 ns/op
BenchmarkSort-8   	   19705	     60792 ns/op
PASS
ok  	github.com/commaok/blog/content/post	11.772s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If the number of iterations looks funny to you, it&#39;s because you are used to seeing round numbers there. That also &lt;a href=&#34;https://golang.org/cl/112155/&#34;&gt;changed in Go 1.13&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Now let&#39;s use the new &lt;code&gt;testing.B.ReportMetric&lt;/code&gt; API to report the number of comparisons. To do this, we need to count the number of comparisons. Then we&#39;ll divide by &lt;code&gt;b.N&lt;/code&gt;. The reason we must do the division ourselves is to allow metrics that aren&#39;t naturally represented as per-op counts, such as ratios or percentiles.&lt;/p&gt;
&lt;p&gt;Here&#39;s the updated code, with added lines marked:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkSort&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cmps&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int64&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;lt;--------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)
	&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResetTimer&lt;/span&gt;() &lt;span style=&#34;color:#75715e&#34;&gt;// remove allocation
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; {
			&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] = &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; ^ &lt;span style=&#34;color:#ae81ff&#34;&gt;0x2cc&lt;/span&gt;
		}
		&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StartTimer&lt;/span&gt;()
		&lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Slice&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; {
			&lt;span style=&#34;color:#a6e22e&#34;&gt;cmps&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;lt;--------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;] &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;]
		})
		&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;StopTimer&lt;/span&gt;()
	}
	&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ReportMetric&lt;/span&gt;(float64(&lt;span style=&#34;color:#a6e22e&#34;&gt;cmps&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;float64(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cmps/op&amp;#34;&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;lt;--------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Running this yields:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go test -bench=. -count=5
goos: darwin
goarch: amd64
pkg: github.com/commaok/blog/content/post
BenchmarkSort-8   	   18523	     69874 ns/op	     10091 cmps/op
BenchmarkSort-8   	   18654	     64621 ns/op	     10091 cmps/op
BenchmarkSort-8   	   18657	     64589 ns/op	     10091 cmps/op
BenchmarkSort-8   	   18774	     64367 ns/op	     10091 cmps/op
BenchmarkSort-8   	   18704	     64408 ns/op	     10091 cmps/op
PASS
ok  	github.com/commaok/blog/content/post	12.062s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that the number of comparisons is stable. This is a wonderful property when benchmarking. It means you can run your benchmarks a small number of times, without quitting your browser or trying to disable thermal scaling or worrying about how your laptop CPU may be different from your production CPUs.&lt;/p&gt;
&lt;p&gt;Now let&#39;s reach into the standard library and tweak something! There&#39;s a function called &lt;a href=&#34;https://golang.org/src/sort/sort.go?s=5609:5622#L223&#34;&gt;&lt;code&gt;maxDepth&lt;/code&gt; inside &lt;code&gt;package sort&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// maxDepth returns a threshold at which quicksort should switch
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// to heapsort. It returns 2*ceil(lg(n+1)).
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxDepth&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;depth&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
		&lt;span style=&#34;color:#a6e22e&#34;&gt;depth&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;depth&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(Aside: maxDepth should probably use &lt;code&gt;math/bits.Len&lt;/code&gt; to calculate &lt;code&gt;ceil(lg(n+1))&lt;/code&gt;. This is another candidate for a good first contribution to the Go core.)&lt;/p&gt;
&lt;p&gt;Let&#39;s make &lt;code&gt;maxDepth&lt;/code&gt; just return 0 instead and re-run our benchmark:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go test -bench=. -count=5 -run=NONE
goos: darwin
goarch: amd64
pkg: github.com/commaok/blog/content/post
BenchmarkSort-8   	   12618	     94792 ns/op	     17426 cmps/op
BenchmarkSort-8   	   12668	     94769 ns/op	     17426 cmps/op
BenchmarkSort-8   	   12642	     94645 ns/op	     17426 cmps/op
BenchmarkSort-8   	   12738	     94623 ns/op	     17426 cmps/op
BenchmarkSort-8   	   12654	     94431 ns/op	     17426 cmps/op
PASS
ok  	github.com/commaok/blog/content/post	12.867s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can see that not only is it slower, but that it is clearly an algorithmic degradation: The number of comparisons has increased markedly.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/perf/benchstat&#34;&gt;benchstat&lt;/a&gt; supports custom metrics, so we can use it to tell us exactly how much:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ benchstat a b
name    old time/op   new time/op   delta
Sort-8   64.5µs ± 0%   94.7µs ± 0%  +46.76%  (p=0.016 n=4+5)

name    old cmps/op   new cmps/op  delta
Sort-8    10.1k ± 0%    17.4k ± 0%  +72.69%  (p=0.008 n=5+5)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There&#39;s one more trick worth worth mentioning. &lt;code&gt;testing.B.ReportMetric&lt;/code&gt; generally overrides built-in metrics. If you call &lt;code&gt;b.ReportMetric(5, &amp;quot;allocs/op&amp;quot;)&lt;/code&gt;, then &lt;code&gt;go test&lt;/code&gt; will report &lt;code&gt;5 allocs/op&lt;/code&gt;, regardless of how much your benchmark actually allocated. There&#39;s one special case: &lt;code&gt;ns/op&lt;/code&gt;. If set to &lt;code&gt;0&lt;/code&gt;, then &lt;code&gt;ns/op&lt;/code&gt; won&#39;t be reported at all. This is useful to avoid confusion or distraction if your benchmark&#39;s elapsed time is meaningless. For example, &lt;a href=&#34;https://golang.org/cl/166959/&#34;&gt;one of the earliest uses of &lt;code&gt;testing.B.ReportAlloc&lt;/code&gt;&lt;/a&gt; was for a &lt;code&gt;package sync&lt;/code&gt; benchmark that reported garbage collector stop-the-world time, in percentiles. It is irrelevant how long it takes that benchmark to run; only the percentiles matter.&lt;/p&gt;
&lt;p&gt;On a sad note, there&#39;s currently &lt;a href=&#34;https://github.com/golang/go/issues/18454&#34;&gt;no good way&lt;/a&gt; to get profiling tools to tell you &lt;em&gt;where&lt;/em&gt; a particular custom metric increased.&lt;/p&gt;
&lt;p&gt;What else could you use &lt;code&gt;testing.B.ReportMetric&lt;/code&gt; for? Obvious use cases include cache hit rates, I/O amounts, fast path/slow path heuristics, percentile reporting, and algorithmic improvements. (We measured comparisons during sorting here; how about swaps?) I&#39;m sure there will be non-obvious ones as well.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Compatibility: Not just about code</title>
      <link>https://commaok.xyz/post/compatibility/</link>
      <pubDate>Wed, 06 Feb 2019 16:05:13 -0800</pubDate>
      
      <guid>https://commaok.xyz/post/compatibility/</guid>
      <description>&lt;p&gt;The &lt;a href=&#34;https://golang.org/doc/go1compat&#34;&gt;Go 1 compatibility promise&lt;/a&gt;
was designed to ensure &amp;ldquo;that Go 1 will be a firm foundation
for the development of Go and its ecosystem.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.golang.org/go2-here-we-come&#34;&gt;Go 2 is coming.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/ianlancetaylor&#34;&gt;Ian Lance Taylor&lt;/a&gt; has written a
masterful, thoroughly researched
&lt;a href=&#34;https://github.com/golang/proposal/blob/master/design/28221-go2-transitions.md&#34;&gt;design document&lt;/a&gt;
about &amp;ldquo;how to make incompatible changes from Go 1 to Go 2 while breaking as little as possible&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Interestingly, both documents are clearly geared towards code and APIs.&lt;/p&gt;
&lt;p&gt;A few examples from the Go 1 compatibility promise (emphasis added):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is intended that &lt;em&gt;programs&lt;/em&gt; written to the Go 1 specification will continue to &lt;em&gt;compile and run correctly, unchanged&lt;/em&gt;, over the lifetime of that specification.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;Compatibility is &lt;em&gt;at the source level&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;Of course, for all of these possibilities, should they arise, we would endeavor whenever feasible to update the specification, compilers, or libraries &lt;em&gt;without affecting existing code&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And from the Go 2 transitions proposal (emphasis added):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A key feature of these options is that &lt;em&gt;code compiled&lt;/em&gt; at different language/library versions can in general all be linked together and work as expected.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;While we can provide tooling to &lt;em&gt;convert pre-1.20 code into working 1.20 code&lt;/em&gt;, we can&#39;t force package authors to run those tools.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;blockquote&gt;
&lt;p&gt;This can be used to take incremental steps toward new language versions, and to make it easier to &lt;em&gt;share the same code&lt;/em&gt; among different language versions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;As we all know, however, there is much more to a language&#39;s ecosystem than the extant body of code.
There is culture. There is infrastructure, like conferences and training. There is tooling. There is trust.
There is an aesthetic. (Ian Lance Taylor&#39;s takeaway from the history of C++: &amp;ldquo;A new version may have a very different feel while remaining backward compatible.&amp;quot;)&lt;/p&gt;
&lt;p&gt;And then there is a giant, sprawling, chaotic mess of documentation,
ranging from official docs to blog posts to Stack Overflow to mailing list archives and beyond.&lt;/p&gt;
&lt;p&gt;This organic documentary hodgepodge is invaluable.
With the help of search engines, it ensures that most questions
will have multiple answers written in different ways, at different levels, by different authors.
This is a great boon, particularly to newcomers to a language.&lt;/p&gt;
&lt;p&gt;A year ago or so, I needed to write something in Swift. The single biggest pain point by far
was that when I searched for examples and discussion, I found answers written
for Swift 2, Swift 3, and Swift 4. I ended up having to simultaneously learn three dialects
of Swift and how to translate between them. This situation also commonly arises with popular libraries.&lt;/p&gt;
&lt;p&gt;My code was brand new, so I didn&#39;t care that the language had changed in incompatible ways.
But it sure did break the documentation ecosystem in a deep way.
And docs, unlike code, are impossible to &lt;a href=&#34;https://blog.golang.org/introducing-gofix&#34;&gt;go fix&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Of course, docs do go stale even when there is backwards compatibility. For example, strings.Builder
made some old performance advice obsolete. But such breakage is relatively localized, easy to repair gradually,
and not particularly damaging to people who find it instead of up-to-date docs.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;https://github.com/golang/go/issues/20706&#34;&gt;tentatively&lt;/a&gt; &lt;a href=&#34;https://github.com/golang/go/issues/19308&#34;&gt;accepted&lt;/a&gt;
&lt;a href=&#34;https://github.com/golang/go/issues/28493&#34;&gt;Go 2&lt;/a&gt; &lt;a href=&#34;https://github.com/golang/go/issues/19113&#34;&gt;changes&lt;/a&gt;
look unlikely to break much documentation,
and the discussion so far on the &lt;a href=&#34;https://github.com/golang/go/labels/Go2&#34;&gt;many Go 2 proposals&lt;/a&gt; give no particular reason for concern.
Nevertheless, as we all ponder Go 2, it&#39;s probably worth explicitly thinking about
compatibility in terms much broader than working code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Benchmarking package initialization</title>
      <link>https://commaok.xyz/post/benchmark-init/</link>
      <pubDate>Thu, 31 Jan 2019 13:53:05 -0800</pubDate>
      
      <guid>https://commaok.xyz/post/benchmark-init/</guid>
      <description>&lt;p&gt;Go program execution doesn&#39;t start at &lt;code&gt;func main&lt;/code&gt;.
First is &lt;a href=&#34;https://github.com/golang/go/blob/9473c044f1d492a6ba49ec695042dec4365d70ca/src/runtime/asm_amd64.s#L87&#34;&gt;a bit of bootstrapping&lt;/a&gt;.
Then the &lt;a href=&#34;https://github.com/golang/go/blob/688667716ede8b133d361db0a1d47eab24ced7f7/src/runtime/proc.go#L518&#34;&gt;runtime gets initialized&lt;/a&gt;.
Then, package by package, the program initializes global variables and runs &lt;code&gt;init&lt;/code&gt; functions.
Then it&#39;s time for &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Usually, the startup time for a Go program is negligible,
and irrelevant compared to its steady state performance.&lt;/p&gt;
&lt;p&gt;For short-lived programs, though, startup performance can matter a lot.
This is particularly true if &lt;a href=&#34;https://golang.org/issue/29382&#34;&gt;the program is a low level tool that is executed repeatedly by other programs&lt;/a&gt;.
There has also been &lt;a href=&#34;https://golang.org/issue/26775&#34;&gt;recent interest in optimizing the startup impact of the standard library&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;So: How do you benchmark and profile program initialization?&lt;/p&gt;
&lt;p&gt;If you are interested in memory allocation, &lt;a href=&#34;https://github.com/bradfitz&#34;&gt;Brad Fitzpatrick&lt;/a&gt; has &lt;a href=&#34;https://play.golang.org/p/9ervXCWzV_z&#34;&gt;a simple solution&lt;/a&gt;. This works because &lt;a href=&#34;https://commaok.xyz/post/memprofilerate/&#34;&gt;memory profiling is on by default&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But what about execution time?&lt;/p&gt;
&lt;p&gt;One obvious idea is to copy your global variables and init functions into a regular Go benchmark. This is tedious and (like most tedious things) error-prone. It also fails for a more subtle reason: The compiler generates different (slower) code for variable initialization when it occurs inside a function instead of at the top level. This is because the compiler can make fewer assumptions (although as always &lt;a href=&#34;https://golang.org/issue/29573#issuecomment-451596366&#34;&gt;there are ways to improve&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Another idea is to hack your code to return immediately from &lt;code&gt;main&lt;/code&gt; and then use &lt;a href=&#34;https://github.com/aclements/go-misc/blob/master/benchcmd/main.go&#34;&gt;&lt;code&gt;benchcmd&lt;/code&gt;&lt;/a&gt; to benchmark and &lt;a href=&#34;https://en.wikipedia.org/wiki/Perf_%28Linux%29&#34;&gt;&lt;code&gt;perf&lt;/code&gt;&lt;/a&gt; to profile. This works on Linux, although it’d be nicer to have an option that uses standard Go tooling. Also, because initialization is generally fast, you need to do a bunch of runs to gather data, and the exec and profiler tool overhead can be considerable. (I tried using macOS’s &lt;code&gt;instruments&lt;/code&gt; for profiling the &lt;code&gt;go&lt;/code&gt; tool&#39;s startup and found that—in addition to being generally useless—it added &lt;em&gt;300x&lt;/em&gt; overhead per run!)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Instead, let’s &lt;a href=&#34;https://golang.org/doc/go1compat&#34;&gt;void the warranty&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Here’s &lt;a href=&#34;https://github.com/golang/go/blob/faf187fb8e2ca074711ed254c72ffbaed4383c64/src/cmd/compile/internal/gc/init.go#L58&#34;&gt;how the compiler implements package initialization&lt;/a&gt;, at least as of Go 1.12. For each package, it generates code like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;initdone&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;·&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;() {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;initdone&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;·&lt;/span&gt; &amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;initdone&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;·&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
		&lt;span style=&#34;color:#a6e22e&#34;&gt;throw&lt;/span&gt;()
	}
	&lt;span style=&#34;color:#a6e22e&#34;&gt;initdone&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;·&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
	&lt;span style=&#34;color:#75715e&#34;&gt;// for all imported packages {
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;pkg&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;()
	&lt;span style=&#34;color:#75715e&#34;&gt;// }
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ializers&lt;/span&gt;()
	
	&lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;.&amp;lt;&lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;&amp;gt;() &lt;span style=&#34;color:#75715e&#34;&gt;// call user init functions, if any
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;initdone&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;·&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ializers&lt;/span&gt;() {                          (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
	{ &amp;lt;&lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;global&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;variables&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;this&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt;&amp;gt; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This &lt;code&gt;init&lt;/code&gt; takes the place of any &lt;code&gt;init&lt;/code&gt; functions in the package; those are renamed &lt;code&gt;init.0&lt;/code&gt;, &lt;code&gt;init.1&lt;/code&gt;, and so on.&lt;/p&gt;
&lt;p&gt;If we could reset &lt;code&gt;initdone·&lt;/code&gt; to 0 and then call this &lt;code&gt;init&lt;/code&gt; function, then we’d be (re-)executing the exact code that gets executed during package initialization.&lt;/p&gt;
&lt;p&gt;We can do that! We&#39;ll use &lt;a href=&#34;https://github.com/golang/go/blob/5efe9a8f11c81116f102f56c49a9415fd992c038/src/cmd/compile/doc.go#L168&#34;&gt;&lt;code&gt;//go:linkname&lt;/code&gt;&lt;/a&gt; to get access.&lt;/p&gt;
&lt;p&gt;Here&#39;s an example, benchmarking &lt;code&gt;net/http&lt;/code&gt; package initialization:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;p_test&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
	&lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;net/http&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// must import net/http, so that net/http.init actually ends up in the executable
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;testing&amp;#34;&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;unsafe&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// must import unsafe to use go:linkname
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;)

&lt;span style=&#34;color:#75715e&#34;&gt;//go:linkname _initdone net/http.initdone·
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_initdone&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;//go:linkname _init net/http.init
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_init&lt;/span&gt;()

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BenchmarkNetHTTPInit&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;testing&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;N&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; {
		&lt;span style=&#34;color:#a6e22e&#34;&gt;_initdone&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
		&lt;span style=&#34;color:#a6e22e&#34;&gt;_init&lt;/span&gt;()
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And voila! A regular old Go benchmark that does just what we want.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Mostly. There are a few gotchas, above and beyond merely being a terrible idea.&lt;/p&gt;
&lt;p&gt;First, if you do non-idempotent work in one of your &lt;code&gt;init&lt;/code&gt; functions, things could get wonky. We did just void the warranty, after all. And I don’t know what might happen if you re-initialize package runtime or testing or something else low level while running a benchmark. Almost certainly something bad.&lt;/p&gt;
&lt;p&gt;Second, as written, this only measures the initialization of &lt;code&gt;net/http&lt;/code&gt; and &lt;em&gt;not any of its dependencies&lt;/em&gt;. This might or might not be want you want. You can work around this by using more &lt;code&gt;//go:linkname&lt;/code&gt; to reset &lt;code&gt;initdone·&lt;/code&gt; to 0 for all dependencies. Then, as you can see from the compiler pseudocode, a single call to &lt;code&gt;_init&lt;/code&gt; will re-initialize those packages as well.&lt;/p&gt;
&lt;p&gt;Third, using &lt;code&gt;//go:linkname&lt;/code&gt; requires that the symbol we are linkname-ing to must actually be in the executable. The easiest way to do this is to import the package in question. If you are working with an internal package, that means you might need to put this code somewhere with sufficient visibility for that import to work.&lt;/p&gt;
&lt;p&gt;Fourth, line number support for autogenerated code isn&#39;t all that fabulous. If you encounter frustrating pprof output while doing this, consider &lt;a href=&#34;https://golang.org/issue/new&#34;&gt;filing bugs&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Now that you can benchmark, what do you do if you find a bottleneck you want to fix? Mostly, lazily initialize things instead, usually using &lt;a href=&#34;https://golang.org/pkg/sync/#Once&#34;&gt;&lt;code&gt;sync.Once&lt;/code&gt;&lt;/a&gt;, which is fast and hopefully &lt;a href=&#34;https://golang.org/cl/152697&#34;&gt;will be faster still in Go 1.13&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Thanks to &lt;a href=&#34;https://github.com/mvdan&#34;&gt;Daniel Martí&lt;/a&gt; for posing this question and for reading an early draft of this blog post.&lt;/p&gt;
&lt;p&gt;Daniel has also created a tool based on this blog post, &lt;a href=&#34;https://github.com/mvdan/benchinit&#34;&gt;benchinit&lt;/a&gt;, so that you can &lt;a href=&#34;https://github.com/golang/go/issues/19348#issuecomment-309446070&#34;&gt;break your programs&lt;/a&gt; this way with even less effort.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Logging, interfaces, and allocation</title>
      <link>https://commaok.xyz/post/interface-allocs/</link>
      <pubDate>Mon, 06 Feb 2017 10:52:40 -0800</pubDate>
      
      <guid>https://commaok.xyz/post/interface-allocs/</guid>
      <description>&lt;p&gt;This post is about some new compiler optimizations scheduled for Go 1.9,
but I want to start with logging.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;A couple of weeks ago, Peter Bourgon started a
&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-dev/F3l9Iz1JX4g&#34;&gt;thread on golang-dev about standardizing logging&lt;/a&gt;.
Logging is pervasive, so performance came up quickly.
The &lt;a href=&#34;https://github.com/go-kit/kit/tree/master/log&#34;&gt;go-kit log package&lt;/a&gt; uses structured logging,
centered on this interface:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Logger&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;Log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;keyvals&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{}) &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Sample call:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;logger&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;transport&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;HTTP&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;addr&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;addr&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;msg&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;listening&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that everything that goes into a logging call gets converted into an interface.
This means that it allocates a lot.&lt;/p&gt;
&lt;p&gt;Compare with another structured logger, &lt;a href=&#34;https://github.com/uber-go/zap&#34;&gt;zap&lt;/a&gt;.
Zap has uglier call sites, specifically to avoid using interfaces, in order to be zero-allocation:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;logger&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Info&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to fetch URL.&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;zap&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;),
  &lt;span style=&#34;color:#a6e22e&#34;&gt;zap&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Int&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;attempt&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;tryNum&lt;/span&gt;),
  &lt;span style=&#34;color:#a6e22e&#34;&gt;zap&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Duration&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;backoff&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;sleepFor&lt;/span&gt;),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The arguments to &lt;code&gt;logger.Info&lt;/code&gt; have type &lt;code&gt;logger.Field&lt;/code&gt;.
&lt;code&gt;logger.Field&lt;/code&gt; is a kind of union-ish struct
that includes a type and a field each for a &lt;code&gt;string&lt;/code&gt;, an &lt;code&gt;int&lt;/code&gt;, and an &lt;code&gt;interface{}&lt;/code&gt;.
Thus interfaces are not necessary to pass the most common kinds of values.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Enough about logging. Why does converting a concrete value to an interface sometime allocate?&lt;/p&gt;
&lt;p&gt;Interfaces are represented as two words, a type pointer and a value pointer.
Russ Cox wrote a &lt;a href=&#34;https://research.swtch.com/interfaces&#34;&gt;lovely explanation of this&lt;/a&gt;,
which I will not attempt to repeat. Just go read it.&lt;/p&gt;
&lt;p&gt;His post is slightly out of date, however.
He points out an obvious optimization: When the value is pointer-sized or smaller,
we can just put the value directly into the second interface word.
However, with the advent of concurrent garbage collection,
&lt;a href=&#34;https://golang.org/issue/8405&#34;&gt;that optimization got eliminated&lt;/a&gt;.
Now the second word in the interface is always a pointer.&lt;/p&gt;
&lt;p&gt;Consider:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Before Go 1.4, this code did not allocate,
because the value &lt;code&gt;1&lt;/code&gt; could be put directly into the second interface word.&lt;/p&gt;
&lt;p&gt;That is, the compiler treated it something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;({&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;where &lt;code&gt;{typ, val}&lt;/code&gt; represents the two words in an interface.&lt;/p&gt;
&lt;p&gt;As of Go 1.4, this code started allocating, because &lt;code&gt;1&lt;/code&gt; is not a pointer,
and the second word must contain a pointer.
So instead the compiler+runtime conspired to turn it into something roughly like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; new(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// allocates!
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;({&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This was painful, and there was much wringing of hands and gnashing of teeth.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;https://github.com/golang/go/commit/22701339817a591cd352ecd43b0439b84dbe8095&#34;&gt;first significant optimization to remove allocations&lt;/a&gt;
was added a bit later. It kicked in when the resulting interface did not escape.
In that case, the temporary value could be put on the stack instead of the heap.
Using our example code above:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; new(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// now doesn&amp;#39;t allocate, as long as e doesn&amp;#39;t escape
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{} = {&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;}
&lt;span style=&#34;color:#75715e&#34;&gt;// do things with e that don&amp;#39;t make it escape
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Unfortunately, many interfaces do escape, including those used in calls
to &lt;code&gt;fmt.Println&lt;/code&gt; and in our logging examples above.&lt;/p&gt;
&lt;p&gt;Happily, Go 1.9 will bring a few more optimizations,
in part inspired by the logging conversation.
(Unless those optimizations get reverted in the next six months,
which is always a possibility.)&lt;/p&gt;
&lt;p&gt;The first optimization is &lt;a href=&#34;https://golang.org/issue/18704&#34;&gt;to not allocate to convert a constant to an interface&lt;/a&gt;.
So &lt;code&gt;fmt.Println(1)&lt;/code&gt; will no longer allocate. The compiler puts
the value &lt;code&gt;1&lt;/code&gt; in a readonly global, roughly like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// at the top level, marked as readonly
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;({&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is possible because constants are immutable,
and will thus be the same every time the interface conversion is reached,
including recursively and concurrently.&lt;/p&gt;
&lt;p&gt;This was inspired directly by the logging discussion.
In structured logging, many of the arguments are constants&amp;ndash;
almost certainly all the keys, and probably a few of the values.
Recall the go-kit example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;logger&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;transport&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;HTTP&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;addr&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;addr&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;msg&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;listening&amp;#34;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This code drops from 6 allocations to 1, because five of the arguments are constant strings.&lt;/p&gt;
&lt;p&gt;The second new optimization is &lt;a href=&#34;https://golang.org/issue/17725&#34;&gt;to not allocate to convert bools and bytes to interfaces&lt;/a&gt;.
This optimization works by adding a global &lt;code&gt;[256]byte&lt;/code&gt; array called &lt;code&gt;staticbytes&lt;/code&gt; to every binary,
where &lt;code&gt;staticbytes[b] = b&lt;/code&gt; for all b.
When the compiler wants to put a bool or uint8 or other single-byte value
into an interface, instead of allocating, it calculates a pointer into this array.
That is:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;staticbytes&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;256&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt; = {&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;}

&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; uint8(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;({&lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;staticbytes&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;]})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There is a third new optimization proposed that is still under review,
which is &lt;a href=&#34;https://golang.org/cl/36476&#34;&gt;to not allocate to convert common zero values in an interface&lt;/a&gt;.
It applies to integers, floats, strings, and slices.
This optimization works by checking at runtime whether the value is &lt;code&gt;0&lt;/code&gt; (or &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;).
If so, it uses a pointer to &lt;a href=&#34;https://github.com/golang/go/blob/go1.8rc3/src/runtime/hashmap.go#L1182&#34;&gt;an existing large chunk of zeroed memory&lt;/a&gt;
rather than allocating some memory and zeroing it.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;If all goes well, Go 1.9 should eliminate a fair number of allocations during interface conversions.
But it won&#39;t eliminate all of them, which leaves performance still on the table as the logging discussion continues.&lt;/p&gt;
&lt;p&gt;The interplay between implementation decisions and APIs is interesting.&lt;/p&gt;
&lt;p&gt;Picking an API requires thinking about the performance consequences.
It is not an accident that &lt;code&gt;io.Reader&lt;/code&gt; requires/allows callers to bring their own buffer.&lt;/p&gt;
&lt;p&gt;Performance is in no small part a consequence of the implementation decisions.
We have seen in this post that the implementation details of interfaces can substantially alter
what code allocates.&lt;/p&gt;
&lt;p&gt;And yet those very implementation decisions depend on what kind of code people write.
The compiler and runtime authors want to optimize real, common code.
For example, the &lt;a href=&#34;https://golang.org/issue/8405&#34;&gt;decision to in Go 1.4 to keep interface values at two words instead of changing them to three&lt;/a&gt;,
which made &lt;code&gt;fmt.Println(1)&lt;/code&gt; allocate, was based on looking at the kind of code people wrote.&lt;/p&gt;
&lt;p&gt;Since the kind of code people write is often shaped heavily by the APIs they use,
we have the kind of organic feedback loop that is fascinating and sometimes challenging to manage.&lt;/p&gt;
&lt;p&gt;Not a terribly deep observation, perhaps, but there is one takeaway:
If you&#39;re designing an API and worrying about performance,
keep in mind not just what the existing compiler and runtime actually do,
but what they could do.
Write code for the present, but design APIs for the future.&lt;/p&gt;
&lt;p&gt;And if you&#39;re not sure, ask. It worked (a bit) for logging.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Picking up pennies: Disabling memory profiling</title>
      <link>https://commaok.xyz/post/memprofilerate/</link>
      <pubDate>Sat, 28 Jan 2017 18:06:36 -0800</pubDate>
      
      <guid>https://commaok.xyz/post/memprofilerate/</guid>
      <description>&lt;p&gt;If you work on a short-lived, allocation heavy program
and care about a tiny (maybe 0.5%) performance improvement,
this post is for you.&lt;/p&gt;
&lt;p&gt;I was looking at a CPU profile of the &lt;a href=&#34;https://golang.org/cmd/compile/&#34;&gt;Go compiler&lt;/a&gt;
when I noticed something odd: An entry in &lt;a href=&#34;https://github.com/golang/go/blob/go1.8rc3/src/runtime/mprof.go&#34;&gt;&lt;code&gt;mprof.go&lt;/code&gt;&lt;/a&gt;.
&lt;code&gt;mprof.go&lt;/code&gt; contains the memory profiling implementation, but I was doing cpu profiling.
Was there a bug in &lt;a href=&#34;https://godoc.org/rsc.io/compilebench&#34;&gt;compilebench&lt;/a&gt;, perhaps?&lt;/p&gt;
&lt;p&gt;Nope. The variable &lt;a href=&#34;https://golang.org/pkg/runtime/#pkg-variables&#34;&gt;&lt;code&gt;runtime.MemProfileRate&lt;/code&gt;&lt;/a&gt;
controls the rate at which the runtime samples allocations.
And its default value is not 0 (disabled), but &lt;code&gt;512 * 1024&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is a good default.
One sample per 500k of allocations is not much overhead.
And when something goes wrong on a server, you want to be able to find out why,
rather than fussing with profiling settings and then hoping it happens again.&lt;/p&gt;
&lt;p&gt;But if you work on a short-lived program, like a compiler,
when something goes wrong, you probably don&#39;t have any mechanism for gathering ad hoc profiles.
For any given run, you either have profiling enabled or you don&#39;t,
and if something goes wrong, you just enable profiling and try again.&lt;/p&gt;
&lt;p&gt;And if your program is allocation-heavy, like the Go compiler,
there might be enough memory profiling samples collected to absorb some CPU time.
(As currently implemented, the first sample is particularly expensive,
as it allocates a pretty large data structure.)&lt;/p&gt;
&lt;p&gt;And I&#39;m always looking for performance wins in the compiler, even little ones (hoping they add up).
So I sent a CL to &lt;a href=&#34;https://go-review.googlesource.com/c/35916/&#34;&gt;disable memory profiling entirely when not explicitly requested&lt;/a&gt;.
The benefits aren&#39;t head-turning, but it&#39;s a very cheap, low risk 0.5% to put in the bank.
It&#39;ll get reviewed for Go 1.9.&lt;/p&gt;
&lt;p&gt;Doing this in your own program requires nothing more than setting
&lt;code&gt;runtime.MemProfileRate = 0&lt;/code&gt; when memory profiling has not been requested.
But please, think twice first.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Compile-time assertions in Go</title>
      <link>https://commaok.xyz/post/compile-time-assertions/</link>
      <pubDate>Tue, 24 Jan 2017 09:37:05 -0800</pubDate>
      
      <guid>https://commaok.xyz/post/compile-time-assertions/</guid>
      <description>&lt;p&gt;This post is about a little-known way to make compile-time assertions in Go.
You probably shouldn&#39;t use it, but it is interesting to know about.&lt;/p&gt;
&lt;p&gt;As a warm-up, here&#39;s a fairly well-known form of compile-time assertions in Go: Interface satisfaction checks.&lt;/p&gt;
&lt;p&gt;In this code (&lt;a href=&#34;https://play.golang.org/p/MJ6zF1oNsX&#34;&gt;playground&lt;/a&gt;),
the &lt;code&gt;var _ =&lt;/code&gt; line ensures that type &lt;code&gt;W&lt;/code&gt; is a &lt;code&gt;stringWriter&lt;/code&gt;,
as checked for by &lt;a href=&#34;https://golang.org/pkg/io/#WriteString&#34;&gt;&lt;code&gt;io.WriteString&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;io&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;W&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt;{}

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;W&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Write&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;) (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)       { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;), &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; }
&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;W&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;WriteString&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;), &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; }

&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stringWriter&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
	&lt;span style=&#34;color:#a6e22e&#34;&gt;WriteString&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;error&lt;/span&gt;)
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stringWriter&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;W&lt;/span&gt;{}

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;W&lt;/span&gt;
	&lt;span style=&#34;color:#a6e22e&#34;&gt;io&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;WriteString&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;very long string&amp;#34;&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you comment out &lt;code&gt;W&lt;/code&gt;&#39;s &lt;code&gt;WriteString&lt;/code&gt; method, the code will not compile:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main.go:14: cannot use W literal (type W) as type stringWriter in assignment:
	W does not implement stringWriter (missing WriteString method)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is useful. For most types that satisfy both &lt;code&gt;io.Writer&lt;/code&gt; and &lt;code&gt;stringWriter&lt;/code&gt;,
if you eliminate the &lt;code&gt;WriteString&lt;/code&gt; method, everything will continue to work
as it did before, but with worse performance.&lt;/p&gt;
&lt;p&gt;Rather than trying to write a fragile test for a performance regression using
&lt;a href=&#34;https://golang.org/pkg/testing/#AllocsPerRun&#34;&gt;&lt;code&gt;testing.T.AllocsPerRun&lt;/code&gt;&lt;/a&gt;,
you can simply protect your code with a compile-time assertion.&lt;/p&gt;
&lt;p&gt;Here&#39;s &lt;a href=&#34;https://github.com/golang/go/blob/go1.8rc2/src/io/multi.go#L72&#34;&gt;a real world example of this technique from package io&lt;/a&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;OK, onward to obscurity!&lt;/p&gt;
&lt;p&gt;Interface satisfaction checks are great.
But what if you wanted to check a plain old boolean expression, like &lt;code&gt;1+1==2&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Consider this code (&lt;a href=&#34;https://play.golang.org/p/mjIMWsWu4V&#34;&gt;playground&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;crypto/md5&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Hash&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;() {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;Hash&lt;/span&gt;{}) &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;md5&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Size&lt;/span&gt; {
		panic(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hash is too small&amp;#34;&lt;/span&gt;)
	}
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
	&lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Hash&lt;/code&gt; is perhaps some kind of abstracted hash result.
The &lt;code&gt;init&lt;/code&gt; function ensures that it will work with &lt;a href=&#34;https://golang.org/pkg/crypto/md5/&#34;&gt;crypto/md5&lt;/a&gt;.
If you change &lt;code&gt;Hash&lt;/code&gt; to be (say) &lt;code&gt;[8]byte&lt;/code&gt;, it&#39;ll panic when the process starts.
However, this is a run-time check.
What if we wanted it to fail earlier?&lt;/p&gt;
&lt;p&gt;Here&#39;s how. (There&#39;s no playground link, because this doesn&#39;t work on the playground.)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;C&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;crypto/md5&amp;#34;&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Hash&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;byte&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hashIsTooSmall&lt;/span&gt;()

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;() {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(&lt;span style=&#34;color:#a6e22e&#34;&gt;Hash&lt;/span&gt;{}) &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;md5&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Size&lt;/span&gt; {
		&lt;span style=&#34;color:#a6e22e&#34;&gt;hashIsTooSmall&lt;/span&gt;()
	}
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
	&lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now if you change &lt;code&gt;Hash&lt;/code&gt; to be &lt;code&gt;[8]byte&lt;/code&gt;, it will fail during compilation.
(Actually, it fails during linking. Close enough for our purposes.)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ go build .
&lt;span style=&#34;color:#75715e&#34;&gt;# demo&lt;/span&gt;
main.hashIsTooSmall: call to external &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;
main.init.1: relocation target main.hashIsTooSmall not defined
main.init.1: undefined: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;main.hashIsTooSmall&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;What&#39;s going on here?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hashIsTooSmall&lt;/code&gt; is &lt;a href=&#34;https://golang.org/ref/spec#Function_declarations&#34;&gt;declared without a function body&lt;/a&gt;.
The compiler assumes that someone else will provide an implementation,
perhaps an assembly routine.&lt;/p&gt;
&lt;p&gt;When the compiler can prove that &lt;code&gt;len(Hash{}) &amp;lt; md5.Size&lt;/code&gt;,
it eliminates the code inside the if statement.
As a result, no one uses the function &lt;code&gt;hashIsTooSmall&lt;/code&gt;,
so the linker eliminates it. No harm done.
As soon as the assertion fails, the code inside the if statement is preserved.
&lt;code&gt;hashIsTooSmall&lt;/code&gt; can&#39;t be eliminated.
The linker then notices that no one else has provided an implementation
for the function and fails with an error, which was the goal.&lt;/p&gt;
&lt;p&gt;One last oddity: Why &lt;code&gt;import &amp;quot;C&amp;quot;&lt;/code&gt;?
The go tool knows that in normal Go code, all functions must have bodies,
and instructs the compiler to enforce that.
By switching to cgo, we remove that check.
(If you run &lt;code&gt;go build -x&lt;/code&gt; on the code above, without the &lt;code&gt;import &amp;quot;C&amp;quot;&lt;/code&gt; line,
you will see that the compiler is invoked with the &lt;code&gt;-complete&lt;/code&gt; flag.)
An alternative to adding &lt;code&gt;import &amp;quot;C&amp;quot;&lt;/code&gt; is to &lt;a href=&#34;https://github.com/golang/go/blob/go1.8rc2/src/os/signal/sig.s&#34;&gt;add an empty file called &lt;code&gt;foo.s&lt;/code&gt;
to the package&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I know of only one use of this technique,
in the &lt;a href=&#34;https://github.com/golang/go/blob/go1.8rc2/test/fixedbugs/issue9608.dir/issue9608.go&#34;&gt;compiler test suite&lt;/a&gt;.
There are other &lt;a href=&#34;https://github.com/golang/go/blob/go1.8rc2/src/runtime/hashmap.go#L261&#34;&gt;imaginable places to apply it&lt;/a&gt;,
but no one has bothered.&lt;/p&gt;
&lt;p&gt;And that&#39;s probably how it should be. :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>new(Blog)</title>
      <link>https://commaok.xyz/post/new-blog/</link>
      <pubDate>Mon, 23 Jan 2017 15:19:05 -0800</pubDate>
      
      <guid>https://commaok.xyz/post/new-blog/</guid>
      <description>&lt;p&gt;I&#39;m going to try this blogging thing again.&lt;/p&gt;
&lt;p&gt;I&#39;ve failed at it a few times before.
I&#39;m going to try &lt;a href=&#34;https://jvns.ca/blog/2016/05/22/how-do-you-write-blog-posts/&#34;&gt;Julia Evans&lt;/a&gt; style this time.
Maybe this one will stick?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
